/***********************************************************************************************************************
* DISCLAIMER
* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products.
* No other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
* applicable laws, including copyright laws. 
* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED
* OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY
* LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE FOR ANY DIRECT,
* INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR
* ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability 
* of this software. By using this software, you agree to the additional terms and conditions found by accessing the 
* following link:
* http://www.renesas.com/disclaimer
*
* Copyright (C) 2020 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/

/***********************************************************************************************************************
*  File Name    : H_T_Sensor_RL78_Training.c
*  Description  : Main Program
*  Creation Date: 2025-02-13
*  This file was generated by Smart Configurator.
***********************************************************************************************************************/
#include "r_smc_entry.h"
#include "r_rfd_common_api.h"
#include "r_rfd_common_control_api.h"
#include "r_rfd_data_flash_api.h"
#include "G23_FPB_data_flash.h"

/* Including the APIs for the HS4001 Sensor Module */
#include "r_hs400x_if.h"
#include "r_comms_i2c_if.h"
#include "r_bsp_config.h"

/* Define the States for the State Machine */
typedef enum {
    STATE_WAITING, // State when the Machine is in Idle and the Timer is Running
	STATE_WAITING_FOR_HT_CALC,
    STATE_READ_HT_SENSOR_START,
	STATE_READ_HT_SENSOR_READ,
	STATE_READ_HT_SENSOR_CALC,
    STATE_READ_INTERNAL_TEMPERATURE,
	STATE_STORE_VALUE,
	STATE_PRINT_DATA,
	STATE_COMPARE,
	STATE_ENTERING_LPM,
	STATE_ESCAPING_LPM,
	STATE_ERROR
} state_t;

// Necessary for data flash access
#define WRITE_BUFFER_SIZE 	2U
#define DF_WRITE_START_ADDRESS    (0x000F1000uL)

/* Define global variables */
static rm_hs400x_raw_data_t             gs_hs400x_raw_data;
static volatile rm_hs400x_data_t        gs_hs400x_data;
static fsp_err_t						err;
state_t									g_currentState = STATE_WAITING;
extern bool								g_interrupt_flag_ADC;
extern bool								g_interrupt_flag_UART;
uint16_t								g_temperature_internal[1] = {0};
uint8_t									g_dataFlash_blockNumber = 0;

int main (void);
void g_comms_i2c_bus0_quick_setup(void);
void g_hs400x_sensor0_quick_setup(void);
void timer_callback(void);

/* Quick setup for g_comms_i2c_bus0. */
void g_comms_i2c_bus0_quick_setup(void)
{
/* bus has been opened by startup procees */
}

/* Quick setup for g_hs400x_sensor0. */
void g_hs400x_sensor0_quick_setup(void)
{
	/* Open HS400X sensor instance, this must be done before calling any HS400X API */
	err = RM_HS400X_Open(g_hs400x_sensor0.p_ctrl, g_hs400x_sensor0.p_cfg);
	if(err != FSP_SUCCESS)
	{
		g_currentState = STATE_ERROR;
	}
}

/* Callback Functions*/
void hs400x_user_i2c_callback0(rm_hs400x_callback_args_t * p_args)
{
	if (RM_HS400X_EVENT_SUCCESS == p_args->event)
	    {
			switch(g_currentState)
			{
			case STATE_WAITING:
				g_currentState = STATE_READ_HT_SENSOR_READ;
				break;
			case STATE_WAITING_FOR_HT_CALC:
				g_currentState = STATE_READ_HT_SENSOR_CALC;
				break;
			}
	    }
	    else
	    {
	    	g_currentState = STATE_ERROR;
	    }
}

void timer_callback()
{
	g_currentState = STATE_READ_HT_SENSOR_START;
	PIN_WRITE(LED1) = ~PIN_WRITE(LED1);
}


int main(void)
{
	EI();

	/* Open the Bus */
	g_comms_i2c_bus0_quick_setup();
	/* Open HS400X */
	g_hs400x_sensor0_quick_setup();

	// Start the Timer
	R_Config_TAU0_0_Start();

	// Prepare the ADC for conversion
	R_Config_ADC_Set_OperationOn();

	// ====Setting up the DataFlash access====
	uint32_t       l_mclk_freq;
	e_rfd_ret_t    l_e_rfd_status_flag;
	e_sample_ret_t l_e_sam_ret_status;

	l_mclk_freq = R_BSP_GetFclkFreqHz()/1000000;

	// Initialize RFD library with the CPU frequency
	l_e_rfd_status_flag = R_RFD_Init((uint8_t)l_mclk_freq);
	if (R_RFD_ENUM_RET_STS_OK != l_e_rfd_status_flag)
		g_currentState = STATE_ERROR;
	// Set the flash sequencer in Data flash memory programming mode
	l_e_rfd_status_flag = R_RFD_SetFlashMemoryMode(R_RFD_ENUM_FLASH_MODE_DATA_PROGRAMMING);
	if (R_RFD_ENUM_RET_STS_OK != l_e_rfd_status_flag)
			g_currentState = STATE_ERROR;

	// Config UART
	R_Config_UARTA1_Create();


	//=======================================
	MD_STATUS g_uarta1_tx_end = 0U;     /* uartA0 transmission end */
	// Main loop
	while(1){

		switch(g_currentState)
		{
			case STATE_WAITING:
				break;
			case STATE_WAITING_FOR_HT_CALC:
				break;
			case STATE_READ_HT_SENSOR_START:
				err = RM_HS400X_MeasurementStart(g_hs400x_sensor0.p_ctrl);
				if(err == FSP_SUCCESS)
				{
					g_currentState = STATE_WAITING;
				}else{

					g_currentState = STATE_ERROR;
				}
				break;
			case STATE_READ_HT_SENSOR_READ:
				err = RM_HS400X_Read(g_hs400x_sensor0.p_ctrl, &gs_hs400x_raw_data);
				if(err == FSP_SUCCESS)
				{
					g_currentState = STATE_WAITING_FOR_HT_CALC;
				}else{

					g_currentState = STATE_ERROR;
				}

				break;
			case STATE_READ_HT_SENSOR_CALC:
				//err = RM_HS400X_DataCalculate(g_hs400x_sensor0.p_ctrl,&gs_hs400x_raw_data,(rm_hs400x_data_t *)&gs_hs400x_data);
				gs_hs400x_data;

				g_currentState = (err == FSP_SUCCESS) ? STATE_READ_INTERNAL_TEMPERATURE : STATE_ERROR;
				break;

			case STATE_READ_INTERNAL_TEMPERATURE:


				g_interrupt_flag_ADC = false;
				R_Config_ADC_Start();

				// Wait for the interrupt of the ADC
				while(!g_interrupt_flag_ADC);

				// Read the ADC value
				ADIF = 0U;						/* Clear INTAD request */
				R_Config_ADC_Get_Result_12bit(g_temperature_internal);
				R_Config_ADC_Stop ();

				//TODO: Change to STORE DATA
				g_currentState = STATE_PRINT_DATA;
				break;
			case STATE_STORE_VALUE:
				// Store the Data in the Data Flash

				// Check if the block is blank -> if not erase
				R_RFD_BlankCheckDataFlashReq(g_dataFlash_blockNumber);
				l_e_sam_ret_status = Sample_CheckCFDFSeqEnd();
				if (SAMPLE_ENUM_RET_ERR_ACT_BLANKCHECK == l_e_sam_ret_status)
				{
					R_RFD_EraseDataFlashReq(g_dataFlash_blockNumber);

					l_e_sam_ret_status = Sample_CheckCFDFSeqEnd();

					if (SAMPLE_ENUM_RET_STS_OK != l_e_sam_ret_status){
						g_currentState = STATE_ERROR;
						break;
					}
				}
			    else if (SAMPLE_ENUM_RET_STS_OK != l_e_sam_ret_status)
			    {
			    	g_currentState = STATE_ERROR;
					break;
			    }

				// Write data to the block
				/*Since the size of the datatype is uint16, it takes 2 bytes of space*/
				uint8_t write_buffer[WRITE_BUFFER_SIZE] = {
				    (uint8_t)(g_temperature_internal[0] & 0xFF),       // Low-Byte
				    (uint8_t)((g_temperature_internal[0] >> 8) & 0xFF) // High-Byte
				};


				uint16_t byte_count = 0;
				for (byte_count = 0; byte_count < WRITE_BUFFER_SIZE; byte_count++)
				{

					R_RFD_WriteDataFlashReq(DF_WRITE_START_ADDRESS + (g_dataFlash_blockNumber*4) + byte_count, &write_buffer[byte_count] );

					l_e_sam_ret_status = Sample_CheckCFDFSeqEnd();

					if (SAMPLE_ENUM_RET_STS_OK != l_e_sam_ret_status)
					{
						g_currentState = STATE_ERROR;
						break;
					}

				}

				// Set flash sequence in non-programmable mode after all operations are completed
				// If this is uncommented the flash will be locked and reprogramming isn't possible
//				l_e_rfd_status_flag = R_RFD_SetFlashMemoryMode(R_RFD_ENUM_FLASH_MODE_UNPROGRAMMABLE);
//
//				if (R_RFD_ENUM_RET_STS_OK != l_e_rfd_status_flag)
//				{
//					g_currentState = STATE_ERROR;
//				}
				g_currentState = STATE_WAITING;
				//P5_bit.no3 = 0;
				g_dataFlash_blockNumber++;
				if(g_dataFlash_blockNumber > 9) g_dataFlash_blockNumber = 0;
				break;
			case STATE_PRINT_DATA:
				// Print Sensor Data to terminal
				R_Config_UARTA1_Start();
				uint8_t tx_buf1[] = {0x3B};

				g_uarta1_tx_end = R_Config_UARTA1_Send(tx_buf1, sizeof(tx_buf1));

				// blocking: wait until transmitting done
				while(!g_interrupt_flag_UART);

				R_Config_UARTA1_Stop();
				g_interrupt_flag_UART = false; // reset the flag
				break;
			case STATE_ERROR:
				//R_Config_TAU0_0_Stop();
				PIN_WRITE(LED2) = false; // Set LEDs High
				break;
			default:
				g_currentState = STATE_ERROR;
			break;
		}

	}

    return 0;
}
