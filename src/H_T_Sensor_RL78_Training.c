/***********************************************************************************************************************
* DISCLAIMER
* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products.
* No other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
* applicable laws, including copyright laws. 
* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED
* OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY
* LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE FOR ANY DIRECT,
* INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR
* ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability 
* of this software. By using this software, you agree to the additional terms and conditions found by accessing the 
* following link:
* http://www.renesas.com/disclaimer
*
* Copyright (C) 2020 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/

/***********************************************************************************************************************
*  File Name    : H_T_Sensor_RL78_Training.c
*  Description  : Main Program
*  Creation Date: 2025-02-13
*  This file was generated by Smart Configurator.
***********************************************************************************************************************/
#include "r_smc_entry.h"

/* Including the APIs for the HS4001 Sensor Module */
#include "r_hs400x_if.h"
#include "r_comms_i2c_if.h"
#include "r_bsp_config.h"

/* Define the States for the State Machine */
typedef enum {
    STATE_WAITING, // State when the Machine is in Idle and the Timer is Running
	STATE_WAITING_FOR_HT_CALC,
    STATE_READ_HT_SENSOR_START,
	STATE_READ_HT_SENSOR_READ,
	STATE_READ_HT_SENSOR_CALC,
    STATE_READ_INTERNAL_TEMPERATURE,
	STATE_STORE_VALUE,
	STATE_PRINT_DATA,
	STATE_COMPARE,
	STATE_ENTERING_LPM,
	STATE_ESCAPING_LPM,
	STATE_ERROR
} state_t;


/* Define global variables */
static rm_hs400x_raw_data_t             gs_hs400x_raw_data;
static volatile rm_hs400x_data_t        gs_hs400x_data;
static fsp_err_t						err;
state_t									g_currentState = STATE_WAITING;
extern bool								g_interrupt_flag_ADC;
uint16_t								g_temperature_internal[1] = {0};

int main (void);
void g_comms_i2c_bus0_quick_setup(void);
void g_hs400x_sensor0_quick_setup(void);
void timer_callback(void);

/* Quick setup for g_comms_i2c_bus0. */
void g_comms_i2c_bus0_quick_setup(void)
{
/* bus has been opened by startup procees */
}

/* Quick setup for g_hs400x_sensor0. */
void g_hs400x_sensor0_quick_setup(void)
{
	/* Open HS400X sensor instance, this must be done before calling any HS400X API */
	err = RM_HS400X_Open(g_hs400x_sensor0.p_ctrl, g_hs400x_sensor0.p_cfg);
	if(err != FSP_SUCCESS)
	{
		g_currentState = STATE_ERROR;
	}
}

/* Callback Functions*/
void hs400x_user_i2c_callback0(rm_hs400x_callback_args_t * p_args)
{
	if (RM_HS400X_EVENT_SUCCESS == p_args->event)
	    {
			switch(g_currentState)
			{
			case STATE_WAITING:
				g_currentState = STATE_READ_HT_SENSOR_READ;
				break;
			case STATE_WAITING_FOR_HT_CALC:
				g_currentState = STATE_READ_HT_SENSOR_CALC;
				break;
			}
	    }
	    else
	    {
	    	g_currentState = STATE_ERROR;
	    }
}

void timer_callback()
{
	g_currentState = STATE_READ_HT_SENSOR_START;
	PIN_WRITE(LED1) = ~PIN_WRITE(LED1);
}


int main(void)
{
	EI();

	/* Open the Bus */
	g_comms_i2c_bus0_quick_setup();
	/* Open HS400X */
	g_hs400x_sensor0_quick_setup();

	// Start the Timer
	R_Config_TAU0_0_Start();

	// Prepare the ADC for conversion
	R_Config_ADC_Set_OperationOn();

	// Main loop
	while(1){

		switch(g_currentState)
		{
			case STATE_WAITING:
				break;
			case STATE_WAITING_FOR_HT_CALC:
				break;
			case STATE_READ_HT_SENSOR_START:
				err = RM_HS400X_MeasurementStart(g_hs400x_sensor0.p_ctrl);
				if(err == FSP_SUCCESS)
				{
					g_currentState = STATE_WAITING;
				}else{

					g_currentState = STATE_ERROR;
				}
				break;
			case STATE_READ_HT_SENSOR_READ:
				err = RM_HS400X_Read(g_hs400x_sensor0.p_ctrl, &gs_hs400x_raw_data);
				if(err == FSP_SUCCESS)
				{
					g_currentState = STATE_WAITING_FOR_HT_CALC;
				}else{

					g_currentState = STATE_ERROR;
				}

				break;
			case STATE_READ_HT_SENSOR_CALC:
				//err = RM_HS400X_DataCalculate(g_hs400x_sensor0.p_ctrl,&gs_hs400x_raw_data,(rm_hs400x_data_t *)&gs_hs400x_data);
				gs_hs400x_data;
				if(err == FSP_SUCCESS)
				{

					g_currentState = STATE_READ_INTERNAL_TEMPERATURE;
				}else{

					g_currentState = STATE_ERROR;
				}
				break;

			case STATE_READ_INTERNAL_TEMPERATURE:


				g_interrupt_flag_ADC = false;
				R_Config_ADC_Start();

				// Wait for the interrupt of the ADC
				while(!g_interrupt_flag_ADC);

				// Read the ADC value
				ADIF = 0U;						/* Clear INTAD request */
				R_Config_ADC_Get_Result_12bit(g_temperature_internal);
				R_Config_ADC_Stop ();

				g_currentState = STATE_WAITING;
				break;

			case STATE_ERROR:
				//R_Config_TAU0_0_Stop();
				PIN_WRITE(LED2) = false; // Set LEDs High
				break;
			default:
				g_currentState = STATE_ERROR;
			break;
		}

	}

    return 0;
}
